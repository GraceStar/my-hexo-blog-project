---
title: 聊聊JVM
date: 2023-4-05 23:10:05
tags: java
---

> 引言：最近重翻了下《深入理解Java虚拟机》这本经典，本文算是读书小结吧
<!--more-->
# 一，Java和JVM
## 1.1 Java技术体系
Java技术体系包括以下几个组成部分：
* Java程序设计语言
* 各种硬件平台上的Java虚拟机
* Class文件格式
* Java API类库
* 来自商业机构和开源社区的第三方Java类库

Java程序设计语言、Java虚拟机、Java API类库这三部分统称为JDK（Java Development Kit），JDK是用于支持Java程序开发的最小环境，在后面的内容中，为了讲解方便，有一些地方会以JDK来代替整个Java技术体系。另外，可以把Java API类库中的Java SE API子集和Java虚拟机这两部分统称为JRE（Java Runtime Environment），JRE是支持Java程序运行的标准环境。
![](/img/17004875937915.jpg)

## 1.2 Java和JVM发展史
Java是一门历史悠久的语言，从1995年开始发展至今。Java虚拟机历史上有非常多的版本，先后有很多公司下场开发过优秀的版本（微软,IBM,Apache,BEA,SUN,Oracal,Google等），这里面还伴随有各种竞争，收购等等故事。目前有根据不同场景广泛使用的不同JVM，以及延伸出来的改造版JVM, 如Android虚拟机（Dalvik和ART）。后者被认为是Java生态系统的割裂，因为其执行的是.dex文件，而不是.class文件。

下面讲到的是应用最广泛的Oracal的HotSpot JVM。
## 1.3 JVM的一些概念纠正
1）JVM并不是单一为Java设计的，Java的生态规划是多语言混合编程，JVM是可以支持多种语言的，比如Groovy, PHP, Lua，Ruby等等。
他们的区别在于前端编译器是不同的，但是最终都会编程为.class文件运行在JVM上。每种语言对应的JVM的版本也不一样。
![](/img/17004886045740.jpg)
2）Java的设计规定是比较宽泛的，每个JDK都有不少自己的自由发挥空间。目前通用的约定是《Java虚拟机规范》，目前最近的版本是Java SE 8 版本，https://docs.oracle.com/javase/specs/jvms/se8/html/。

3）Java这门语言其实更多的设计及优化是服务于服务端开发。如果有过Java服务端开发经验，相信你会对JVM有更深刻的感悟。
# 二，Java内存区域
Java相比C++来说对开发者更加友好，开发者无需自己维护对象生命周期，不容易出现内存泄露，内存溢出等问题。因为Java有自己的虚拟机内存管理机制和GC机制。
从语言层面来说，Java提供了更多高阶功能，多态，反射，泛型，函数式编程等等，这些一方面为开发者提供了更好用的编程环境，另一方便也让JDK变的更加复杂，增加了隐形的开销。

作为客户端开发，你可能会面临不同语言及其带来的技术栈。这些都会涉及各种VM的知识，C++ VM和JVM是个不错的入手建议。

## 2.1 运行时数据存储
Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。
这里的运行时数据存储模型和后文会提到的Java内存模型是两个维度的划分，两者没有关系，这里是根据数据存储位置的划分，后者是按照资源交互的层级划分。

![](/img/17004902765126.jpg)
其中方法区和堆是线程共享的，虚拟机栈、本地方法栈、程序计数器是线程私有的。
1. 程序计数器：当前线程所执行的字节码的行号指示器。
2. Java虚拟机栈：生命周期和线程相同，描述的是Java方法执行的内存模型。每个方法的调用到执行完成都伴随着一个栈帧的入栈出栈。每个栈帧里存着局部变量表，操作数栈，动态链接，方法出口等信息。
3. 本地方法栈：跟Java虚拟机栈类似，只不过存储的是Native方法的相关信息。至于具体语言，虚拟机规范中并没有强制规定，常见的比如c++。
4. Java堆：最大的一块，虚拟机启动时创建，唯一目的就是存放对象实例。Java堆也是GC的主要管理区域。Java堆中可能划分出多个TLAB（线程私有分配缓冲区）。
5. 方法区：又叫Non-heap，用于存储类信息，常量，静态变量，JIT编译后的代码等。这部分的内存也会被GC回收，但是频率非常低，条件很苛刻。
  * 运行时常量池：编译期生成的（类加载后）各种字面量和符号引用。    

## 2.2 HotSpotVM中的对象内存
### 1） 对象创建：new之后发生了什么？
1. 检查new指令参数是否能在常量池定位到类的符号引用，并检查这个类是否被加载、解析、初始化。如果没，执行类的加载。
2. 从堆中给对象划分空间。类加载完成后，类对象所需空间即确定。这个过程可能会涉及GC。
   其中需要考虑的问题是线程安全问题：对分配内存空间的动作做同步处理(CAS+失败重试);TLAB。
3. 分配的内存空间初始化为零：这也就保证了对象的实例字段在Java代码中可以不赋初始值直接使用。
4. 填充对象的对象头（Object Head），包括对象类的元数据信息，对象的hash code，对象的gc分代年龄，锁相关的信息等。
5. 调用<init>方法，即类的构造函数进行初始化。

### 2） 对象的内存布局：
一个对象在堆中的内存布局分为三部分：**对象头，实例数据和对齐填充**。
1. 对象头。分为两部分信息，一个是对象自身的运行时数据(Mark World)，如HashCode,GC年龄分代，锁相关的信息，一般是1-2个slot大小，非固定数据结构。一个是类型指针，指向类元数据指针，如果是数组还会记录数据长度。虚拟机通过后者确认对象类型。
2. 实例数据。父类继承和子类定位的各种字段都会被记录下来，存储顺序不保证(JVM自己的分配策略)。
3. 对齐填充。这个是为了内存对齐，将对象实例数据填充为8字节整数倍，且起始地址也是8字节整数倍。

### 3） 对象的访问定位：
因为Java程序是通过栈上的reference数据去操作堆上的具体对象的，操作方式在HotSpotVM中是直接指针访问的方式。
图中的对象类型数据即上文中说到的对象头中的类型指针指向的数据，存储在线程共享的方法区。
![](/img/17005380598054.jpg)
# 三，GC和内存分配策略
## 3.1 如何判断对象是否活着
### 1）算法
常见的两种方法：引用计数和可达性分析。
1. 引用计数：具体不再介绍，python里就是使用的引用计数进行内存管理。但是他存在一个bug，就是循环引用的问题。
2. 可达性分析：Java,C#采用的方法。简单来说就是通过一些GC Roots对象为起始点，树形向下搜索，如果有引用链可以到达一个对象，则说明这对象是可用的，否则说明不可用，也就是这个对象可以回收了。
![](/img/17005388931303.jpg)
在Java语言中，可作为GC Roots的对象包括下面几种：
* 虚拟机栈（栈帧中的本地变量表）中引用的对象。
* 方法区中类静态属性引用的对象。
* 方法区中常量引用的对象。
* 本地方法栈中JNI（即一般说的Native方法）引用的对象。
* 
### 2）两次标记
要宣告一个对象是否死亡，要经过两次标记：
第一次是可达性分析后，进行第一次标记，同时进行第一次筛选。如果对象没覆盖finalize方法或者finalize方法已经被VM调用过，则彻底标记死亡。
第二次是如果第一次没被标记死亡，即finalize方法有待调用，则会被放到VM中低优先级的Finalizer线程中的F-Queue队列中，进行第二次小规律标记。
注意每个对象的finalize方法只会被调用一次，**不鼓励自己覆写finalize方法**（运行代价大，不确定性大，无法保证执行顺序）。这个方法完全是为了让c系程序员更好适应的一个妥协（对应析构函数）。

### 3）HotSpot算法实现
全局分析遍历GC Roots非常耗时，这会带来大量的Stop the World时间。为了提高性能，HotSpot中对存活判定进一步优化。
1. 存活判断效率提升。所以HotSpot在对象信息中加上一组OopMap（类加载完成后生成），把对象什么偏移量是什么类型数据标注出来。这样GC Roots直接选定标注为Reference及常量等数据开始遍历即可。
2. 存活判断频率优化。简单来说，就是设置安全点和安全区域。只为安全点的指令生成OopMap，只有当程序进入安全点的时候才执行存活判定。安全点不是任意的选择，既不能太少以至于让收集器等待时间过长，也不能过多以至于过分增大运行时的内存负荷。通常选择一些执行时间较长的指令作为安全点，如方法调用、循环跳转和异常跳转等。JVM中采用主动式中断方式（设置标志，各线程主动轮询，自己挂起）让各个线程到达安全点，再触发中断进行判断。安全区域是解决线程Sleep/Blocked时无法进入安全点的场景，因为这种状态的代码段中引用关系并不会变化，所以只要标注自己进入了安全区域，则区域中任意时间都可GC。

## 3.2 Java对引用的界定
上述两个方法都涉及怎么界定引用，Java根据使用场景扩展了界定：
1. 强引用：狭义的引用。只要强引用存在，GC就不能回收被引用的对象。
2. 软引用SoftRerence：在系统发生内存溢出之前，会把这些对象列入回收范围。
3. 弱引用WeakRerence：对象只能生存到下个GC之前，下次GC一定会回收掉。
4. 虚引用：一般用于调试场景，不影响对象生存时间，也无法通过虚引用获取对象。唯一目的就是被GC的时候会收到系统通知。

## 3.2 垃圾收集算法
常见的垃圾回收算法：
1. 标记清除：带来的问题是效率问题和内存碎片问题。
2. 复制：将可用内存划分为等大的两块，一块用完了，复制到另一块，并对其进行清理。典型的空间换时间，运行简单，高效，但是存在空间浪费。一般JVM会采用这种方法回收新生代（Eden+Survivor:Survivor9:1倒腾+老年代分配担保）。
3. 标记整理：时间换空间。
4. 分代收集：新生代和老年代因为回收频率不同，采用不同算法，如新生代采用复制，老年代采用标记清除/整理。

## 3.4 HotSpot垃圾收集器
这个话题可大了，不同厂家不同版本的垃圾收集器差别很大，这里提到的是HotSpot中的版本。
垃圾回收器之间没有可比性，只是说根据具体应用场景选择最适合的而已。一个JVM里也不至于一种GC Collector，都是一些Collector的组合使用。
![](/img/17005418032331.jpg)

### 1）Serial Collector
历史悠久，单线程，需要stop the world。简单高效，适合client模式下的虚拟机。
有新老Serial，前者复制算法，后者标记整理。
![](/img/17005420278364.jpg)
### 2）ParNew Collector
可以理解为Serial的多线程版本。适合server模式下的虚拟机。
有新老ParNew，前者复制算法，后者标记整理。ParNew Old也是多线程。
![](/img/17005421186692.jpg)
### 3）Parallel Collector
多线程，复制算法，适合新生代。关注可控制的吞吐量（可通过参数设置），也叫吞吐量优先收集器，适合server模式下的虚拟机。
这里引入一个GC性能考量的一个指标概念：吞吐量(吞吐量 = 运行用户代码时间 /（运行用户代码时间 +垃圾收集时间）)和停顿时间。
* 停顿时间短：则适合需要和用户交互的程序，良好的响应速度能提升用户体验，
* 高吞吐量则：可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。
可见，客户端关注的是GC停顿时间，而后台关注的是GC吞吐量。

### 3）CMS Collector
并发收集，低停顿。优点是停顿时间最短，实现较为复杂。
![](/img/17005427729455.jpg)
实现方式，讲整个过程分为初始标记-并发标记-重新标记-并发清除。
其中13需要stop the world，但是不耗时，24耗时但是并发执行。由此达到停顿时间最短。
CMS的缺点：
* CMS并发执行时会抢占线程资源，导致总吞吐量下降
* 无法处理并行标记清除阶段产生的垃圾，即浮动垃圾。
* CMS的标记清除带来的内存碎片问题，可能会引起Full GC。

常见的组合是Serial/ParNew(New)+CMS(Old), 也是JDK1.6之前的主要GC模型。
### 4）G1 Collector
JDK1.7正式商用，可以通过java -XX:+PrintCommandLineFlags -version查看自己本地的Java环境里的GC类型。
![](/img/17005461339728.jpg)
比如我的Java17版本就是使用的G1。
G1是一款面向服务端应用的，未来规划会替代CMS的GC。G1是一款独立的GC,不需要和其他GC配合使用。
特点是：并行与并发，分代，空间整合（无空间碎片），可预测的停顿。
G1的重要特点是Java堆的内存布局是划分为多个大小相等的Region，虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。

G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（这也就是Garbage-First名称的来由）。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。

G1这种内存布局的方式会带来更多的复杂性，比如多个Region之间的相互引用，会给GC Root带来更多的复杂性。为此G1采用Remembered Set来避免全堆扫描的。这里具体不再展开。
G1的运作流程类似CMS, 也分为初始标记-并发标记-重新标记-并发清除四个阶段。

## 3.5 内存分配和回收策略
Java内存分配和回收构成了**Java内存管理**。首先这部分处理的都是堆上的空间，其次分配和回收策略都是不是百分百固定的，跟垃圾收集器组合、虚拟机内存相关参数设置等有关。
普遍的内存分配原则是（堆中分为Eden+Survivor+Survivor,空间8:1:1,Eden+Survivor统称新生代）：
1. 对象优先分配在Eden区，Eden空间不够了，就发起一次Minor GC。
2. 大对象直接进入老年代。大对象即大量连续内存空间的Java对象，如很长的字符串及数组。写代码时尽量避免，他们会提前触发GC腾地方。
3. 长期存活的对象进入老年代。首次Minor GC后存活的对象进入Survivor，后续每次Minor GCAge就会增加一岁，当增加到阈值年龄（可设置，默认15岁），进入老年代。
4. 动态年龄判断。应对大家年龄比较平均的情况，当Survivor中相同年龄的对象占至少一半，则比他们大的进入老年代。
5. 空间分配担保。上文讲到复制算法的时候提到，JVM中是Eden+Survivor:Survivor即9:1的空间比例倒腾，那势必会伴随着倒腾不开的问题，这个时候需要老年代参与空间担保，就好比贷款担保一样。
   Minor GC之前，虚拟机会检查老年代最大可用空间是否大于新生代所有对象总空间，如果不够，继续检查是否大于历次晋升到老年代的平均大小。如果大于，则尝试Minor GC, 如果小于，则会进行Full GC。这就好比担保时资产评估和信用评估的区别。

这里引入两个概念Minor GC和Major GC/Full GC:
* Minor GC:新生态GC，频繁，速度快
* Major GC/Full GC: 老年代GC,Major GC通常伴随至少一次Minor GC。Major GC速度一般比Minor GC慢十倍以上。

# 四，JDK提供的命令行工具
关于命令行工具，是JDK为开发者提供的当前平台的调试工具。例如运行日志，异常堆栈，GC日志，threaddump, headdump文件。他们位于jdk/bin下面，体积很小，因为主要逻辑位于jdk/lib/tools.jar。
这些工具方便我们在纯Java环境下进行Java程序的调试，对后台部署初期是很有意义的。客户端开发一般不会直接使用，更多是使用IDE来进行调试，后者也是基于这些命令行工具的封装。
![](/img/17005521185044.jpg)
上面是常见的调试监控命令行，很多命令都和linux命令类似，如ps，stat。

# 五，类文件结构
Java著名的口号“Write Once，Run Anywhere”，是基于字节码的程序存储格式。也就是Java或者其他语言通过前端编译器，编译为语言无关的字节码文件.class。.class文件运行在JVM上，JVM不和任意语言绑定，而是和.class文件关联。.class文件是Java虚拟机指令集和符号表以及若干其他辅助信息。
我们可以通过javap命令行查看class字节码。
![](/img/17005526151188.jpg)
## 5.1 Class类文件结构
Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到需要占用8位字节以上空间的数据项时，则会按照**大端方式**分割成若干个8位字节进行存储。
根据Java虚拟机规范的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：无符号数和表。
表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表。

![](/img/17005528160344.jpg)


1. 魔术和Class文件版本
共8个字节。
每个Class文件的头4个字节称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。Class文件的魔术是0xCAFEBABE。
紧接着魔数的4个字节存储的是Class文件的版本号，也就是对应JDK的版本号。JDK具有向后兼容性。

2. 常量池
常量池可以理解为Class文件之中的资源仓库，它是Class文件结构中与其他项目关联最多的数据类型，也是占用Class文件空间最大的数据项目之一。
常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。字面量比较接近于Java语言层面的常量概念，如文本字符串、声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括了下面三类常量：
* 类和接口的全限定名（Fully Qualified Name）
* 字段的名称和描述符（Descriptor）
* 方法的名称和描述符

**为什么常量池这么重要呢？**因为不同于c++在编译时的链接步骤，函数等直接替换成对应的相对偏移地址。Java代码不是在编译期，而是在虚拟机加载Class文件的时候（运行期）进行动态连接。也就是说，在Class文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。

常量池中每一项常量都是一个表。
![](/img/17005539813993.jpg)

3. 访问标志
2个字节定长，用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等。

4. 类索引，父类索引和接口索引集合
类索引（this_class）和父类索引（super_class）都是一个u2类型的数据，而接口索引集合（interfaces）是一组u2类型的数据的集合，Class文件中由这三项数据来确定这个类的继承关系。
它们各自指向一个类型为CONSTANT_Class_info的类描述符常量，通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串。
![](/img/17005542609510.jpg)

5. 字段表集合
字段表（field_info）用于描述接口或者类中声明的变量。字段（field）包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量（存在栈上）。
字段表集合中不会列出从超类或者父接口中继承而来的字段，但有可能列出原本Java代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段this。
字段表如下，依次包括了访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attributes）几项。
![](/img/17005546212070.jpg)

6. 方法表集合
Class文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。
方法里的Java代码，经过编译器编译成字节码指令后，存放在方法属性表集合中一个名为“Code”的属性里面。
与字段表集合相对应的，如果父类方法在子类中没有被重写（Override），方法表集合中就不会出现来自父类的方法信息。但同样的，有可能会出现由编译器自动添加的方法，最典型的便是类构造器“<clinit>”方法和实例构造器“<init>”方法。

7. 属性表集合
在Class文件、字段表、方法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息。属性表就好比详细备注，是其他几个表的子选项。
常见的几个属性有：
* Code属性：
有具体实现的方法（除接口，抽象类中的方法）会有这个属性。存储的是方法经过javac编译后的字节码指令。
![](/img/17005552265060.jpg)
Code属性是Class文件中的重要属性，它的存在说明Java程序中的信息可以分为代码和元数据（类，字段，方法定义和其他信息）。
从Code属性表可见，编译完成时，方法的最大操作数栈深，局部变量所需存储空间都是确定的了。异常表实际上是Java代码的一部分，编译器使用异常表而不是简单的跳转命令来实现Java异常及finally处理机制。

* Exceptions属性：
  Exceptions属性的作用是列举出方法中可能抛出的受查异常（Checked Excepitons），也就是方法描述时在throws关键字后面列举的异常。
  
* ConstantValue属性：
ConstantValue属性的作用是通知虚拟机自动为静态变量赋值。只有被final static关键字修饰的变量（类变量）才可以使用这项属性。而对ConstantValue的属性值只能限于基本类型和String。
![](/img/17005557674955.jpg)

* InnerClass属性：
InnerClasses属性用于记录内部类与宿主类之间的关联。如果一个类中定义了内部类，那编译器将会为它以及它所包含的内部类生成InnerClasses属性。
![](/img/17005558313985.jpg)

![](/img/17005558572189.jpg)


* Signature属性：
Signature属性在JDK 1.5发布后增加到了Class文件规范之中，它是一个可选的定长属性，可以出现于类、属性表和方法表结构的属性表中。这个属性是为定义泛型类型而设计的。
因为Java语言的泛型采用的是擦除法实现的伪泛型，在字节码（Code属性）中，泛型信息编译（类型变量、参数化类型）之后都通通被擦除掉。使用擦除法的好处是实现简单（主要修改Javac编译器，虚拟机内部只做了很少的改动）、非常容易实现Backport，运行期也能够节省一些类型所占的内存空间。但坏处是运行期就无法像C#等有真泛型支持的语言那样，将泛型类型与用户定义的普通类型同等对待，例如运行期做反射时无法获得到泛型信息。Signature属性就是为了弥补这个缺陷而增设的，现在Java的反射API能够获取泛型类型，最终的数据来源也就是这个属性。

* BootstrapMethods属性：
BootstrapMethods属性在JDK 1.7发布后增加到了Class文件规范之中，它是一个复杂的变长属性，位于类文件的属性表中。这个属性用于保存invokedynamic指令引用的引导方法限定符。
## 5.2 公有设计和私有实现
Java虚拟机规范描绘了Java虚拟机应有的共同程序存储格式：Class文件格式以及字节码指令集。Java虚拟机规范描绘了Java虚拟机应有的共同程序存储格式：Class文件格式以及字节码指令集。
虚拟机实现的方式主要有以下两种：
* 将输入的Java虚拟机代码在加载或执行时翻译成另外一种虚拟机的指令集，如Dalvik虚拟机。
* 将输入的Java虚拟机代码在加载或执行时翻译成宿主机CPU的本地指令集（即JIT代码生成技术）。

# 六，虚拟机类加载机制
上面我们知道了class文件结构是这样的。截止到class文件的生成，这些都发生在编译器。但是class文件最终要被虚拟机加载后才能运行和使用。
虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是**虚拟机的类加载机制**。这些发生在程序运行期。
## 6.1 类加载时机
首先，明确下，Java是支持动态加载的，也就是说用户可以通过Java预定义的和自定义类加载器，让一个本地的应用程序可以在运行时从网络或其他地方加载一个二进制流作为程序代码的一部分。
类的加载包括class文件或者这种二进制流的直接加载。
类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个**生命周期**包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段。其中验证、准备、解析3个部分统称为连接（Linking），这7个阶段的发生顺序如图所示。
![](/img/17005573261777.jpg)
其中连接和初始化的顺序是可以调整的（动态绑定），一般来说JVM是按照这个顺序开始（注意是开始，而不是完成，这些阶段通常是相互交叉混合进行的）的。

JVM规范没有明确类加载时机，明确规定了“有且只有”的类初始化时机：
* 遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。
* 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
* 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
* 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。
* 当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。

除此以外的都是被动引用，是不会触发初始化的。比如：用子类引用父类的静态字段，不会导致子类的初始化；数组定义一组引用类，是不会触发该类的初始化的。

接口的加载过程与类加载过程稍有一些不同，针对接口需要做一些特殊说明：接口也有初始化过程，这点与类是一致的。区别在于初始化场景中的第3种：当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。
## 6.2 类加载过程
### 1）加载
在加载阶段，虚拟机规范规定需要完成以下3件事情：
(1）通过一个类的全限定名来获取定义此类的二进制字节流。
(2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
(3）在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

每个步骤JVM的实现都是很灵活的。
第(1)步有从zip包读取（jar包），网络获取（Applet），运行时计算生成（ProxyGenerator.generateProxyClass来为特定接口生成形式为“*$Proxy”的代理类的二进制字节流），其他文件生成（JSP），数据库读取等等。
这其中非数组类的第(1)步是开发人员可控性最强的，因为加载阶段既可以使用系统提供的引导类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员可以通过定义自己的类加载器去控制字节流的获取方式（即重写一个类加载器的loadClass()方法）。
数组类本身不通过类加载器创建，它是由Java虚拟机直接创建的。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型（Element Type，指的是数组去掉所有维度的类型）最终是要靠类加载器去创建。

第(2)步就是把class二进制流，转化为方法区（对HotSpot就是Non-heap区）内的数据结构。

第(3)步对应HotSpot就是获取一个存储在方法区的Class对象。（不是堆）

### 2） 验证
验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
验证阶段大致上会完成下面4个阶段的检验动作：
* 文件格式验证：第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，如魔术和版本号验证。
* 元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求。
* 字节码验证：是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。实际上JDK1.6之后Code属性的属性表中增加了一项名为“StackMapTable”的属性来简化数据流验证。
* 符号引用验证：发生在虚拟机将符号引用转化为直接引用的解析阶段。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验。

### 3）准备
类变量（static的类变量，非实例变量）分配内存并设置类变量初始值（0值或者ConstValue值）的阶段。
![](/img/17005595613913.jpg)

### 4）解析
解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。
首先引入两个概念：
* 符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。
* 直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，如果有了直接引用，那引用的目标必定已经在内存中存在。

虚拟机规范并未规定解析时间，虚拟机实现可以根据需要来判断到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它。
解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行，分别对应于常量池的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info、CONSTANT_MethodType_info、CONSTANT_MethodHandle_info和CONSTANT_InvokeDynamic_info 7种常量类型。
解析的过程是伴随着符号引用验证的，如果查找失败或者权限不对，会抛出对应Error的，如java.lang.NoSuchMethodError, java.lang.IllegalAccessError。
### 5）初始化
类初始化阶段是类加载过程的最后一步，真正开始执行类中定义的Java程序代码。初始化阶段是执行类构造器<clinit>()方法的过程。

* <clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的。如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<clinit>()方法。
* 虚拟机会保证在子类的<clinit>()方法执行之前，父类的<clinit>()方法已经执行完毕。
* 接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<clinit>()方法。但接口与类不同的是，执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的<clinit>()方法。
* 虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁、同步。

## 6.3 类加载器
类加载器是放到Java虚拟机外部去实现的。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性。通俗说：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义。
绝大部分Java程序都会使用到以下3种系统提供的类加载器：
1. 启动类加载器（Bootstrap ClassLoader）。虚拟机自身一部分，c++实现，负责加载运行时库rt.jar。
2. 扩展类加载器（Extension ClassLoader）。虚拟机自身一部分，c++实现，负责加载<JAVA_HOME>\lib\ext目录下系统类库。
3. 应用程序类加载器（Application ClassLoader）。这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

在三个系统提供的类加载器基础上，我们还可以自定义自己的类加载器。这些类加载器按照双亲委派模型工作。
![](/img/17005618946514.jpg)
双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。

这个模型的好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。对Java程序的安全性起到一定保证，如系统类库不会被覆盖加载运行。

在一些场景下，jvm中的有些设计是会破坏双亲委派模型，如为了JNDI服务提供的线程上下文加载器，代码热替换，模块热部署等。这里不做展开。
# 七，虚拟机字节码执行引擎
上文讲完了字节码的编译和加载，到此位置，运行区内存中的方法区已经有了对应类的静态数据结构，下一步就轮到找到main入口并开始执行代码程序的逻辑了，也就是加载方法列表中code属性里的内容了。类的加载不一定发生在JVM中，但是字节码的执行一定是在JVM中了。
不同虚拟机的字节码执行的实现可能不同，比如有些是解释执行，有些是编译执行，或者两者兼备。
以下介绍概念模型，解释器执行和概念模型的方式比较类似。
## 7.1 运行时栈帧结构
栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。
前面讲过，一个栈帧的大小（局部变量表，操作数栈深）在编译阶段已经计算并存到code属性中。

一个线程中的方法调用链可能会很长，很多方法都同时处于执行状态。对于执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧（Current Stack Frame），与这个栈帧相关联的方法称为当前方法（Current Method）。执行引擎运行的所有字节码指令都只针对当前栈帧进行操作，在概念模型上，典型的栈帧结构如图所示。
![](/img/17005635954690.jpg)

### 1）局部变量表
以slot为最小单位（跟具体机器有关），不够的内存对齐。局部变量表中存储的是有boolean、byte、char、short、int、float、reference和returnAddress 8种类型。其中reference类型对应实例引用，returnAddress已经被异常表代替。
在方法执行时，虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程的，如果执行的是实例方法（非static的方法），那局部变量表中第0位索引的Slot默认是用于传递方法所属对象实例的引用this。
介于有些变量的作用域并不一定会覆盖整个方法体，所以为了尽可能节省栈帧空间，局部变量表中的Slot是可以重用的。这里不再展开。

注意：类的加载过程中会对类变量执行两次初始化（准备阶段和初始化阶段，分别是系统默认值和代码初始值），但是方法体中的局部变量定义了但没有赋初始值是不能使用的，字节码校验的时候也会被虚拟机发现而导致类加载失败。

### 2）操作数栈
操作数栈（Operand Stack）也常称为操作栈，它是一个后入先出（Last In First Out, LIFO）栈。同局部变量表一样，操作数栈的最大深度也在编译的时候写入到Code属性的max_stacks数据项中。操作数栈的每一个元素可以是任意的Java数据类型，包括long和double。
操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，编译器要严格保证这一点，在类校验阶段的数据流分析中还要再次验证这一点。
Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈。
在概念模型中，两个栈帧作为虚拟机栈的元素，是完全相互独立的。但在大多虚拟机的实现里都会做一些优化处理，令两个栈帧出现一部分重叠。这样在进行方法调用时就可以共用一部分数据，无须进行额外的参数复制传递。
![](/img/17005685089460.jpg)

### 3）动态连接
每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）。
字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为**静态解析**。另外一部分将在每一次运行期间转化为直接引用，这部分称为**动态连接**。

### 4）返回地址
两种方式：
* 正常完成出口：有返回值，返回地址通过调用者的pc计数器确定，栈帧中会保存该值。
* 异常完成出口：无返回值，返回地址通过异常处理表确定，栈帧中不会保存该值。对应在方法执行过程中遇到了异常（代码/jvm异常），并且这个异常没有在方法体内得到处理的情况。

方法退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等。

一般会把动态连接、方法返回地址与其他附加信息全部归为一类，称为栈帧信息。
## 7.2 方法调用
方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），暂时还不涉及方法内部的具体运行过程。

Class文件的编译过程中不包含传统编译中的连接步骤，一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址。在类加载期间，甚至到运行期间才能确定目标方法的直接引用。

确定方法究竟是哪个分为解析和分派两种方式，解析一定是静态的，但是分派可能是静态的，也可能是动态的。解析和分派不是二选一的关系，比如静态解析的方法也可能存在静态分配（类的静态方法重载）。
### 1）解析
在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，这种解析能成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。换句话说，调用目标在程序代码写好、编译器进行编译时就必须确定下来。这类“编译期可知，运行期不可变”的方法的调用称为解析（Resolution）。

在Java虚拟机里面提供了5条方法调用字节码指令，分别如下。
* invokestatic：调用静态方法。
* invokespecial：调用实例构造器<init>方法、私有方法和父类方法。
* invokevirtual：调用所有的虚方法。
* invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象。
* invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法，在此之前的4条调用指令，分派逻辑是固化在Java虚拟机内部的，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。

只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本，符合这个条件的有静态方法、私有方法、实例构造器、父类方法4类，它们在类加载的时候就会把符号引用解析为该方法的直接引用。这些方法可以称为非虚方法，与之相反，其他方法称为虚方法（Java方法默认就是虚方法）。
这里面有个例外，就是final方法，虽然是invokevirtual调用，但是因为不能被覆盖，所以没有多态选择，也是非虚方法。
### 2）分派
众所周知，Java是一门面向对象的程序语言，因为Java具备面向对象的3个基本特征：继承、封装和多态。本节讲解的分派调用过程将会揭示多态性特征的一些最基本的体现，如“重载”和“重写”在Java虚拟机之中是如何实现的。

静态和动态分派的区别是根据静态类型还是实际类型进行分派。
* 静态类型：或者叫外观类型，是实际定义的类型，编译器可知，比如方法参数的类型是写死的。
* 实际类型：运行期才确定。

1. 静态分派。
所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。静态分派的典型应用是**方法重载**。
静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的。编译器虽然能确定出方法的重载版本，但在很多情况下这个重载版本并不是“唯一的”，往往只能确定一个“更加合适的”版本。所以字面量没有显式的静态类型，它的静态类型只能通过语言上的规则去理解和推断。

2. 动态分派
在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。动态分派的典型应用是**方法重写override**。
这涉及**invokevirtual指令的多态查找**。简单来说就是invokevirtual指令会找到操作数栈顶的第一个元素所指向的对象的实际类型，然后按照继承链路，寻找与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang. IllegalAccessError异常。

方法的接受者和参数都有可能进行分派，如果只有1种叫单分派，2种叫多分派。Java语言的静态分派属于多分派，动态分派属于单分派类型。
### 3）动态分派的实现
从上文invokevirtual指令的多态查找可知，动态分派的方法版本选择过程需要运行时在类的方法元数据中搜索合适的目标方法。为了提高搜索性能，最常用的优化方法就是在类的方法区建立虚方法表vtable（对应在invokeinterface执行时也会用到接口方法表itable）。使用虚方法表索引来代替元数据查找以提高性能。
虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类中重写了这个方法，子类方法表中的地址将会替换为指向子类实现版本的入口地址。
为了程序实现上的方便，具有相同签名的方法，在父类、子类的虚方法表中都应当具有一样的索引序号，这样当类型变换时，仅需要变更查找的方法表，就可以从不同的虚方法表中按索引转换出所需的入口地址。
方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该类的方法表也初始化完毕。
![](/img/17005717836360.jpg)


## 7.3 动态语言支持
为了更好的支持动态语言，JDK1.7引入invokedynamic指令。
动态类型语言的关键特征是它的类型检查的主体过程是在运行期而不是编译期，满足这个特征的语言有很多，常用的包括：JavaScript、Lua、PHP、Python、Ruby等。
之前的4条方法调用指令（invokevirtual、invokespecial、invokestatic、invokeinterface）的第一个参数都是被调用的方法的符号引用，其分派规则是固话在虚拟机上的，无法自定义。
所以Java虚拟机层面invokedynamic指令以及java.lang.invoke包就是为了Java虚拟机层面上提供动态类型的直接支持，两者都是把如何查找目标方法的决定权从虚拟机转嫁到具体用户代码之中，让用户（包含其他语言的设计者）有更高的自由度。
一个采用上层Java代码和API来实现，另一个用字节码和Class中其他属性、常量来完成。
### 1）java.lang.invoke包
这个包的主要目的是在之前单纯依靠符号引用来确定调用的目标方法这种方式以外，提供一种新的动态确定目标方法的机制，称为MethodHandle（类比C/C++中的Function Pointer，或者C#里面的Delegate类）。
在拥有Method Handle之后，Java语言也可以拥有类似于函数指针或者委托的方法别名的工具。也为lambda表达式奠定了基础。
MethodHandle方法可以在代码中指定分派逻辑。其效果和反射Reflection有众多相似之处。两者的主要区别是：
(1)Reflection是在模拟Java代码层次的方法调用，而MethodHandle是在模拟字节码层次的方法调用。
(2)Reflection是重量级，而MethodHandle是轻量级。Reflection中的java.lang.reflect.Method对象远比MethodHandle机制中的java.lang. invoke.MethodHandle对象所包含的信息多。

### 2）invokedynamic指令
思路和MethodHandle相同，对应过来就是一个“动态调用点”（Dynamic Call Site），java.lang.invoke. CallSite对象，这个代表真正要执行的目标方法调用。也是在程序代码中指定分派逻辑。
**两者的区别在于**，invokedynamic指令所面向的使用者并非Java语言，而是其他Java虚拟机之上的动态语言。因此仅依靠Java语言的编译器Javac没有办法生成带有invokedynamic 指令的字节码。

## 7.4 字节码编译过程
字节码编译过程如图。Java把抽象语法树前的步骤封装成一个半独立的编译器。后面的解释器和中间代码都是在JVM中实现。
![](/img/17005739352026.jpg)
### 1）基于栈的指令集与基于寄存器的指令集
Java编译器输出的指令流，基本上是一种基于栈的指令集架构（Instruction Set Architecture，ISA），指令流中的指令大部分都是零地址指令，它们依赖操作数栈进行工作。
与之相对的另外一套常用的指令集架构是基于寄存器的指令集，比如Dalvik虚拟机。两者适合场景不同。

* 基于栈的指令集主要的优点就是可移植，缺点是由于指令数量和内存访问的原因，所以导致了栈架构指令集的执行速度会相对较慢。
* 基于寄存器的指令集，寄存器由硬件直接提供，程序直接依赖这些硬件寄存器则不可避免地要受到硬件的约束。一般针对固定的cpu架构，如Dalvik虚拟机针对ARM架构。优点是访问速度快。

# 八，前端编译器优化
前端编译器即*.java文件转变成*.class文件的过程，如Javac；后端编译器即JIT编译器或者AOT编译器。Java编译器的性能优化策略主要在后端编译器，这样可以让那些不是由Javac产生的Class文件也同样能享受到编译器优化所带来的好处。
Javac做了许多针对Java语言编码过程的优化措施来改善程序员的编码风格和提高编码效率。如语法糖的实现支持等。
## 8.1 Javac编译器
Javac本身就是一个由Java语言编写的程序。从Sun Javac的代码来看，编译过程大致可以分为3个过程，分别是：
* 解析与填充符号表过程。
* 插入式注解处理器的注解处理过程。
* 分析与字节码生成过程。
![](/img/17005772363404.jpg)
### 1）解析与填充符号表
1. 词法，语法分析
   词法分析是将源代码的字符流转变为标记（Token）集合，单个字符是程序编写过程的最小元素，而标记则是编译过程的最小元素，关键字、变量名、字面量、运算符都可以成为标记，如“int a=b+2”这句代码包含了6个标记，分别是int、a、=、b、+、2，虽然关键字int由3个字符构成，但是它只是一个Token，不可再拆分。
   语法分析是根据Token序列构造抽象语法树的过程，抽象语法树（Abstract Syntax Tree, AST）是一种用来描述程序代码语法结构的树形表示方式，语法树的每一个节点都代表着程序代码中的一个语法结构（Construct），例如包、类型、修饰符、运算符、接口、返回值甚至代码注释等都可以是一个语法结构。

2. 填充符号表
   符号表（Symbol Table）是由一组符号地址和符号信息构成的表格。符号表中所登记的信息在编译的不同阶段都要用到。在语义分析中，符号表所登记的内容将用于语义检查（如检查一个名字的使用和原先的说明是否一致）和产生中间代码。在目标代码生成阶段，当对符号名进行地址分配时，符号表是地址分配的依据。
   
### 2）注解处理器
在JDK 1.5之后，Java语言提供了对注解（Annotation）的支持。这些注解与普通的Java代码一样，是在运行期间发挥作用的。注解处理器可以看做一组编译器的插件，在这些插件里面，可以读取、修改、添加抽象语法树中的任意元素。如果这些插件在处理注解期间对语法树进行了修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止，每一次循环称为一个Round。

### 3）语义分析和字节码生成
语义分析的主要任务是对结构上正确的源程序进行上下文有关性质的审查，如进行类型审查。Java语义分析分为以下三类：
1. 标注检查
   标注检查步骤检查的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配等。在标注检查步骤中，还有一个重要的动作称为常量折叠。
2. 数据及控制流分析
   数据及控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题。
   编译时期的数据及控制流分析与类加载时的数据及控制流分析的目的基本上是一致的，但校验范围有所区别，有一些校验项只有在编译期或运行期才能进行，比如final不变性的校验。
3. 解语法糖desugar
   Java中最常用的语法糖主要是泛型、变长参数、自动装箱/拆箱等，虚拟机运行时不支持这些语法，它们在编译阶段还原回简单的基础语法结构，这个过程称为解语法糖。
## 8.2 Java语法糖
1. 泛型和类型擦除
   不同语言泛型的实现方式不同，分为真泛型和伪泛型，C#属于前者，Java属于后者。
   C#里面泛型无论在程序源码中、编译后的IL中（中间语言，这时候泛型是一个占位符），或是运行期的CLR(.net虚拟机)中，都是切实存在的，List<int>与List<String>就是两个不同的类型，它们在系统运行期生成，有自己的虚方法表和类型数据，这种实现称为类型膨胀，基于这种方法实现的泛型称为**真实泛型**。
   Java语言中的泛型则不一样，它只在程序源码中存在，在编译后的字节码文件中，就已经替换为原来的原生类型（Raw Type，也称为裸类型）了，并且在相应的地方插入了强制转型代码，因此，对于运行期的Java语言来说，ArrayList<int>与ArrayList<String>就是同一个类，所以泛型技术实际上是Java语言的一颗语法糖，Java语言中的泛型实现方法称为类型擦除，基于这种方法实现的泛型称为**伪泛型**。
   由于Java泛型的引入，各种场景（虚拟机解析、反射等）下的方法调用都可能对原有的基础产生影响和新的需求，如在泛型类中如何获取传入的参数化类型等。于是JVM引入了诸如Signature、LocalVariableTypeTable等新的属性用于解决伴随泛型而来的参数类型的识别问题。
   从Signature属性的出现我们还可以得出结论，擦除法所谓的擦除，仅仅是对方法的Code属性中的字节码进行擦除，实际上元数据中还是保留了泛型信息，这也是我们能通过反射手段取得参数化类型的根本依据。
   
2. 自动装箱/拆箱，遍历循环，变长参数
   前端编译器分别会进行类型转换，迭代器，数组类型参数。
3. 条件编译
   在Java语言之中并没有使用预处理器，因为Java语言天然的编译方式（编译器并非一个个地编译Java文件，而是将所有编译单元的语法树顶级节点输入到待处理列表后再进行编译，因此各个文件之间能够互相提供符号信息）无须使用预处理器。
   Java语言中条件编译的实现，也是Java语言的一颗语法糖，根据布尔常量值的真假（编译器就能确定），编译器将会把分支中不成立的代码块消除掉，这一工作将在编译器解除语法糖阶段完成。
   
# 九，后端编译器优化
后端编译器优化策略常见就是JIT,把热点代码编译成平台相关机器码。当然有些JVM里还加上了AOT,进一步提升效率。这块虚拟机规范并没规定，可以自由发挥。

## 9.1 HotSpot中的JIT
HotSpot是采用JIT和解释器并存的混合模式。当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即执行。在程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获取更高的执行效率。当程序运行环境中内存资源限制较大（如部分嵌入式系统中），可以使用解释执行节约内存，反之可以使用编译执行来提升效率。
同时，解释器还可以作为编译器激进优化时的一个“逃生门”，即当激进优化的假设不成立的时候，通过逆优化（Deoptimization）退回到解释状态继续执行。
![](/img/17005795792029.jpg)
HotSpot虚拟机中内置了两个即时编译器，分别称为Client Compiler和Server Compiler，或者简称为C1编译器和C2编译器。之所以用两个JIT,是为分层编译优化策略打基础。
JDK 1.7的Server模式虚拟机中作为默认编译策略被开启。分层编译根据编译器编译、优化的规模与耗时，划分出不同的编译层次，其中包括：
* 第0层，程序解释执行，解释器不开启性能监控功能（Profiling），可触发第1层编译。
* 第1层，也称为C1编译，将字节码编译为本地代码，进行简单、可靠的优化，如有必要将加入性能监控的逻辑。
* 第2层（或2层以上），也称为C2编译，也是将字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。

实施分层编译后，Client Compiler和Server Compiler将会同时工作，许多代码都可能会被多次编译，用Client Compiler获取更高的编译速度，用Server Compiler来获取更好的编译质量，在解释执行的时候也无须再承担收集性能监控信息的任务。

### 1）编译对象和触发条件
那哪些代码会被认为是热点代码呢？什么时候触发JIT呢？
热点代码的判定：
* 被多次调用的方法
* 被多次执行的循环体
实际执行的时候Java是根据基于计数器的热点探测方法。计数器分为方法调用计数器和回边计数器(针对循环体的)。编译器会讲热点方法和热点循环体所在的方法作为编译对象进行编译，并在方法执行过程中进行替换，这个替换过程叫做栈上替换(On Stack Replacement，简称为OSR编译，即方法栈帧还在栈上，方法就被替换了)。
![](/img/17005800703702.jpg)
 
方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减。而这段时间就称为此方法统计的半衰周期，进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的。这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。
回边计数器没有计数热度衰减的过程，因此这个计数器统计的就是该方法循环执行的绝对次数。

以上是Client VM的即时编译方式，对于Server VM来说，执行情况会比上面的描述更复杂一些。
### 2）编译过程
在默认设置下，无论是方法调用产生的即时编译请求，还是OSR编译请求，虚拟机在代码编译器还未完成之前，都仍然将按照解释方式继续执行，而编译动作则在后台的编译线程中进行。

那么在后台执行编译的过程中，编译器做了什么事情呢？Server Compiler和Client Compiler两个编译器的编译过程是不一样的。对于Client Compiler来说，它是一个简单快速的三段式编译器，主要的关注点在于局部性的优化，而放弃了许多耗时较长的全局优化手段。如如方法内联、常量传播，空值检查消除、范围检查消除。
而Server Compiler则是专门面向服务端的典型应用并为服务端的性能配置特别调整过的编译器，也是一个充分优化过的高级编译器，几乎能达到GNU C++编译器使用-O2参数时的优化强度，它会执行所有经典的优化动作，如无用代码消除、循环展开、循环表达式外提、消除公共子表达式、常量传播、基本块重排序等，还会实施一些与Java语言特性密切相关的优化技术。另外，还可能根据解释器或Client Compiler提供的性能监控信息，进行一些不稳定的激进优化。
以即时编译的标准来看，Server Compiler无疑是比较缓慢的，但它的编译速度依然远远超过传统的静态优化编译器，而且它相对于Client Compiler编译输出的代码质量有所提高，可以减少本地代码的执行时间，从而抵消了额外的编译时间开销，所以也有很多非服务端的应用选择使用Server模式的虚拟机运行。

## 9.2 编译优化
在Sun官方的Wiki上，HotSpot虚拟机设计团队列出了一个相对比较全面的、在即时编译器中采用的优化技术列表。这里仅介绍最有代表性的优化技术是如何运作的，它们分别是：
1. 语言无关的经典优化技术之一：公共子表达式消除。
   编译器的经典优化技术。如果一个表达式E已经计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就成为了公共子表达式。对于这种表达式，没有必要花时间再对它进行计算，只需要直接用前面计算过的表达式结果代替E就可以了。

2. 语言相关的经典优化技术之一：数组范围检查消除。
   Java要比C/C++做更多的事情（各种检查判断），这些事情就成为一种隐式开销，如果处理不好它们，就很可能成为一个Java语言比C/C++更慢的因素。要消除这些隐式开销，除了如数组边界检查优化这种尽可能把运行期检查提到编译期完成的思路之外，另外还有一种避免思路——隐式异常处理，Java中空指针检查和算术运算中除数为零的检查都采用了这种思路。
   
3. 最重要的优化技术之一：方法内联。
   方法内联，它是编译器最重要的优化手段之一，除了消除方法调用的成本之外，它更重要的意义是为其他优化手段建立良好的基础。
   Java方法内联很难，因为Java语言中默认的实例方法是虚方法。对于一个虚方法，编译期做内联的时候根本无法确定应该使用哪个方法版本。
   为了解决虚方法的内联问题，引入了一种名为“类型继承关系分析”（CHA）的技术。这是一种基于整个应用程序的类型分析技术，它用于确定在目前已加载的类中，某个接口是否有多于一种的实现，某个类是否存在子类、子类是否为抽象类等信息。
   编译器在进行内联时，如果是非虚方法，那么直接进行内联。如果遇到虚方法，则会向CHA查询此方法在当前程序下是否有多个目标版本可供选择，如果查询结果只有一个版本，那也可以进行内联，不过这种内联就属于激进优化，需要预留一个“逃生门”，称为守护内联。如果向CHA查询出来的结果是有多个版本的目标方法可供选择，则编译器使用内联缓存，工作原理大致就是记录第一次调用的接受者信息并缓存，后续都按这个来，如果后续发生变更，说明使用了这个虚方法的多态特性，则取消内联，回到正常的虚方法表的方式进行分派。

4. 最前沿的优化技术之一：逃逸分析。
   并不是直接优化代码的手段，而是为其他优化手段提供依据的分析技术。
   逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，称为方法逃逸。甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。
   如果能证明一个对象不会逃逸到方法或线程之外，也就是别的方法或线程无法通过任何途径访问到这个对象，则可能为这个变量进行一些高效的优化：
    * 栈上分配：将之前Java堆上分配的对象改为栈上分配，减少GC压力。
    * 同步消除：因为确定了变量不会逃逸出线程，所以对这个变量实施的同步措施就可以消除。
    * 标量替换：如果逃逸分析证明一个对象不会被外部访问，并且这个对象可以被拆散的话（类拆成原始数据类型（int、long等数值类型以及reference类型等）），那程序真正执行的时候将可能不创建这个对象，而改为直接创建它的若干个被这个方法使用到的成员变量来代替。将对象拆分后，除了可以让对象的成员变量在栈上（栈上存储的数据，有很大的概率会被虚拟机分配至物理机器的高速寄存器中存储）分配和读写之外，还可以为后续进一步的优化手段创建条件。

# 十，Java内存模型和线程
先来聊聊真实物理机的内存模型，也就是cpu（可能多核）和内存之间的数据指令交互，为了效率最大化设计的模型。现在的物理机内存模型简单来说如下图。
![](/img/17006367357564.jpg)
为了增加IO效率，cpu增加了3级缓存。为了保证多核cpu的缓存一致性，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI（Illinois Protocol）、MOSI、Synapse、Firefly及Dragon Protocol等。
同时为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行（Out-Of-Order Execution）优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的。
**“内存模型”就是在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。**
不同架构的物理机器可以拥有不一样的内存模型，而Java虚拟机也有自己的内存模型，但是面对的问题相似。
## 10.1 Java内存模型
Java内存模型（Java Memory Model，JMM）需要屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。
Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。
Java内存模型规定了所有的变量（不包括栈上的局部变量与方法参数）都存储在主内存中。每条线程还有自己的工作内存（可与前面讲的处理器高速缓存类比），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的交互关系如图所示。
![](/img/17006372608323.jpg)
### 1）内存交互操作
关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了以下8种原子操作来完成:lock,unlock,read,load,use,assign,store,write。并对两个地方间来回读写的操作指令顺序做了规定。
这些规定很繁琐，可以用等效判断原则——**先行发生原则**，用来确定一个访问在并发环境下是否安全。

### 2）volatile变量特殊规则
关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制。它有两个语义：
* 保证此变量对所有线程的可见性。即当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。
* 禁止指令重排优化。
关于第一点使用中注意，volatile只能保证这个变量是线程安全的，不保证基于这个变量的运算也是线程安全的，这个要自行判断是否加锁。
关于第二点，系统是通过在本地代码中增加内存屏障来保证指令顺序的。从而规避多线程数据依赖造成的重排问题。
一般来说volatile的开销小，但是介于Java锁后续版本做了很多优化，所以两者性能差别不大，应当根据适用场景选择。

### 3）原子性，可见性和有序性
* 原子性：执行过程不会被中断的操作。大致可以认为基本数据类型的访问读写是具备原子性的；在synchronized块之间的操作也具备原子性。
* 可见性：可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。volatile变量，synchronized块，final字段具有可见性。
* 有序性：Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行的语义”（Within-Thread As-If-Serial Semantics），后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。volatile和synchronized两个关键字来保证线程之间操作的有序性。

### 4）先行发生原则
这个原则非常重要，它是判断数据是否存在竞争、线程是否安全的主要依据。
下面是Java内存模型下一些“天然的”先行发生关系，这些先行发生关系无须任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，它们就没有顺序性保障，虚拟机可以对它们随意地进行重排序。
* 程序次序规则：在一个线程内，控制流顺序先后可以保证。
* 管程锁定规则：同一个锁，unlock一定后于lock发生。
* 线程终止规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作。
* 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。
* 对象终结规则：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize方法的开始。
* 传递性：操作A先行发生于操作B，操作B先行发生于操作C，那么操作A先行发生于操作C。

## 10.2 Java线程
Java中线程通过Thread类实现，该类基本都是Native方法，也就是内部实现是平台相关性的。
### 1）线程实现
实现线程主要有3种方式：使用内核线程实现、使用用户线程实现和使用用户线程加轻量级进程混合实现。
1. 使用内核线程实现
   内核线程就是直接由操作系统内核切换，调度，映射到cpu上的线程。
   程序通过内核线程的一种高级接口——轻量级进程（LWP）来使用内核线程。这种轻量级进程与内核线程之间1∶1的关系称为一对一的线程模型。
   ![](/img/17006409239037.jpg)
内核线程的好处是：即使有一个轻量级进程在系统调用中阻塞了，也不会影响整个进程继续工作。
内核线程的坏处是：线程创建操作等涉及系统调用，代价高；内核线程受硬件资源限制总数量有限。
   
2. 使用用户线程实现
   完全建立在用户空间的线程库上，系统内核不能感知线程存在的实现。用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。如果程序实现得当，这种线程不需要切换到内核态，因此操作可以是非常快速且低消耗的，也可以支持规模更大的线程数量。
   ![](/img/17006413608533.jpg)

   用户态线程好处：消耗小，支持大规模线程数量
   用户态线程坏处：过于复杂，诸如阻塞处理，线程映射到cpu很难实现。

3. 使用用户线程加轻量级进程混合实现
   在这种混合实现下，既存在用户线程，也存在轻量级进程。用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发。而操作系统提供支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级线程来完成，大大降低了整个进程被完全阻塞的风险。
   许多UNIX系列的操作系统，如Solaris、HP-UX等都提供了N∶M的线程模型实现。
![](/img/17006414371286.jpg)

### 2）Java线程实现
在目前的JDK版本中，操作系统支持怎样的线程模型，在很大程度上决定了Java虚拟机的线程是怎样映射的，这点在不同的平台上没有办法达成一致。
对于Sun JDK来说，它的Windows版与Linux版都是使用一对一的线程模型实现的；而在Solaris平台中，由于操作系统的线程特性可以同时支持一对一及多对多的线程模型。

### 3）线程调度
主要调度方式有两种，分别是协同式线程调度和抢占式线程调度。
* 协同式调度：线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上。协同式多线程的最大好处是实现简单，无同步问题。坏处是：线程执行时间不可控制，可能存在长时间阻塞。lua的协程就是这种实现。
* 抢占式调度：每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定。线程的执行时间是系统可控的，也不会有一个线程导致整个进程阻塞的问题。

Java的线程调度方式就是抢占式的。这里要提到的是线程的优先级设置并不可靠，因为可能会被操作系统自行改变。

### 4）线程状态转换
![](/img/17006419822934.jpg)
“阻塞状态”与“等待状态”的区别是：“阻塞状态”在等待着获取到一个排他锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。

# 十一，线程安全和锁优化
## 11.1 Java线程安全的实现方式
1. 互斥同步
   同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个（或者是一些，使用信号量的时候）线程使用。而互斥是实现同步的一种手段，临界区、互斥量和信号量都是主要的互斥实现方式。因此，在这4个字里面，互斥是因，同步是果；互斥是方法，同步是目的。
   在Java中，最基本的互斥同步手段就是synchronized关键字。
   * synchronized vs ReentrantLock
     都是可重入锁，JDK1.6之后性能差别不大。ReentrantLock增加了一些高级功能：等待可中断，公平锁，锁绑定多个条件。
   
2. 非阻塞同步
   * 阻塞同步 vs 非阻塞同步
     阻塞同步即互斥同步，是一种悲观的并发策略，总是认为只要不去做正确的同步措施（例如加锁），那就肯定会出现问题，无论共享数据是否真的会出现竞争，它都要进行加锁。
     非阻塞同步，是一种基于冲突检测的乐观并发策略，通俗地说，就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施（最常见的补偿措施就是不断地重试，直到成功为止），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步。其中冲突检测是基于硬件指令集的发展的。
     反应在API使用层面，比如使用Atomic类的CAS操作接口。
       
3. 无需同步方案
   常见的两种场景：
   * 可重入代码，或者叫纯代码。
     如果一个方法，它的返回结果是可以预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的。
   * 线程本地存储。
     如果这些共享数据的代码能保证在同一个线程中执行，则把他们放到ThreadLocal里存储使用。
## 11.2 锁优化
高效并发是从JDK 1.5到JDK 1.6的一个重要改进，HotSpot虚拟机开发团队在这个版本上花费了大量的精力去实现各种锁优化技术，如适应性自旋、锁消除、锁粗化、轻量级锁（Lightweight Locking）和偏向锁等，这些技术都是为了在线程之间更高效地共享数据，以及解决竞争问题，从而提高程序的执行效率。
1. 自旋锁和自适应自旋锁
   **适合场景**:共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。
   **解决思路**:让后面请求锁的那个线程“稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。如果超过一定上限自旋依然没有等到资源，就应当使用传统的方式去挂起线程了。
   **自适应自旋锁**：自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定（根据程序运行和性能监控信息调整）。
   
2. 轻量级锁和偏向锁
   **适合场景**:在没有多线程竞争的前提下，减少/消除传统的重量级锁使用操作系统互斥量产生的性能消耗。这两种都属于一种带有效益权衡（Trade Off）性质的优化（它并不一定总是对程序运行有利）。
   **解决思路**:通过修改对象的Mark Word去记录这个对象的线程使用情况，一旦有竞争，就膨胀为重量级锁。
   
# 十二，总结 
本文我们讲述了JVM的一些概念，按照编译执行顺序，了解了class文件结构，class文件的加载，字节码执行，GC和内存分配，Java运行期内存模型（存储功能划分和IO两个维度），前后端编译器优化，线程相关（实现，调度，状态，安全，锁优化）。