---
title: 浏览器输入域名回车之后发生了什么？
date: 2022-10-01 16:49:16
tags: 前端
---
<meta name="referrer" content="no-referrer"/>
引言：本文帮你回顾计算机网络
<!--more-->
一，浏览器输入域名回车之后的事情
----------------

按照时间线我们来列一下发生的事情：

1.客户端进行DNS域名解析，得到对应的IP地址
    
2.根据这个IP，找到对应的服务器建立连接（三次握手）
    
3.建立TCP连接后发起HTTP请求（一个完整的http请求报文）
    
4.服务器响应HTTP请求，客户端得到html代码
    
5.客户端解析html代码，用html代码中的资源(如js,css,图片等等)渲染页面。
    
6.服务器关闭TCP连接（四次挥手）
    

这几个分别对应的计算机网络知识是DNS解析，网络协议栈，网页解析。最后一步我们在这篇文章里有涉及[一个网页从拿到到展示出来经历了什么-CSDN博客](https://blog.csdn.net/Grace_Luo99/article/details/134180132?spm=1001.2014.3001.5502 "一个网页从拿到到展示出来经历了什么-CSDN博客")

前两个部分我们按照知识点来展开：

二，知识点展开
-------

### 1，计算机网络五层协议结构

目前通用的有几种分类：ISO七层模型、TCP/IP四层模型、五层体系结构。

![](https://img-blog.csdnimg.cn/68d09690b2114003ab709f1bd9fda771.png)

我们这里简单介绍喜爱TCP/IP四层模型：

*   应用层：网络服务与最终用户的一个接口，常见的协议有：**HTTP FTP  SMTP SNMP DNS**。
    
*   传输层: 为应用层实体提供**端到端**的通信功能，保证了数据包的顺序传送及数据的完整性，协议有**TCP UDP**。
    
*   网际层：主要解决**主机到主机**的通信问题，协议有**ICMP IGMP IP等**.。
    
*   网络接口层：与OSI参考模型的数据链路层、物理层对应。
    

从上到下，数据层层封装，每一层的数据封装和分包格式都不同，解决和保证的问题也是不同的，最终协作完成整个网络的数据传输。

### 2，DNS解析

DNS，英文全称是**domain name system**，域名解析系统，是Internet上作为域名和IP相互映射的一个分布式数据库。DNS是应用层协议，是基于UDP的。

DNS的解析过程如下图：

![](https://img-blog.csdnimg.cn/75092c7d57764f8694f4524ae6290afa.png)

假设你要查询**www.baidu.com**的IP地址:

*   首先会查找**浏览器的缓存**,看看是否能找到**www.baidu.com**对应的IP地址，找到就直接返回；否则进行下一步。
    
*   将请求发往给**本地DNS服务器**，如果查找到也直接返回，否则继续进行下一步；
    
*   本地DNS服务器向**根域名服务器**发送请求，根域名服务器返回负责`.com`的顶级域名服务器的IP地址的列表。
    
*   本地DNS服务器再向其中一个**负责`.com`的顶级域名服务器**发送一个请求，返回负责`.baidu`的权威域名服务器的IP地址列表。
    
*   本地DNS服务器再向其中一个**`.baidu`权威域名服务器**发送一个请求，返回**www.baidu.com**所对应的IP地址。
    

### 3，HTTP协议

#### 1) HTTP是什么

网页浏览中使用的最常见的应用层协议，下层一般基于TCP/IP协议族。HTTP是非持久化的，单向的。浏览器发起HTTP请求的默认端口是80端口，HTTP协议头是http://

##### 客户端请求消息

客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，下图给出了请求报文的一般格式。

![](https://img-blog.csdnimg.cn/img_convert/f3ab217de2bc2b5dccae9311556ae2e9.png)

* * *

##### 服务器响应消息

HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。

![](https://img-blog.csdnimg.cn/img_convert/749dba1c7efbce0a6f9b1be9bd48531e.jpeg)

* * *

![](https://img-blog.csdnimg.cn/2104c9c9d3784d08b7be4f6e5d34975d.png)

#### 2) HTTP状态码

![](https://img-blog.csdnimg.cn/fd554788fedf40ec80eafe98fea1495d.png)

#### ![](https://img-blog.csdnimg.cn/e1106b2a9212435f80f042a3cb0392a5.png)

#### 3) HTTP/1.0 1.1 2.0的区别

HTTP1.0

默认短链接，每次请求都需要建立一个TCP连接。它可以设置`Connection: keep-alive` 这个字段，强制开启长连接。

HTTP1.1(2008)

*   引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用。
    
*   引入管道pipeline，在同一个TCP连接里面，客户端可以不等回应同时发送多个请求；坏处是要求服务器按照接收到的请求顺序进行响应，因此，如果管线化中的单个请求执行得很慢，则对客户端的所有后续响应都将相应地延迟下去。这个问题被称为线头阻塞。
    

HTTP2.0(2015)

*   多路复用：HTTP/2 允许同时发送多个请求和响应，而不是像 HTTP/1.1 一样只能一个一个地处理。这样可以减少延迟，提高效率，提高网络吞吐量。
    
*   二进制传输：HTTP/2 使用二进制协议，与 HTTP/1.1 使用的文本协议不同。二进制协议可以更快地解析，更有效地传输数据，减少了传输过程中的开销和延迟。
    
*   头部压缩：HTTP/2 使用 HPACK 算法对 HTTP 头部进行压缩，减少了头部传输的数据量，从而减少了网络延迟。
    
*   服务器推送：HTTP/2 支持服务器推送，允许服务器在客户端请求之前推送资源，以提高性能。
    
*   改进的安全性：HTTP/2 默认使用 TLS（Transport Layer Security）加密传输数据，提高了安全性。
    
*   兼容 HTTP/1.1：HTTP/2 可以与 HTTP/1.1 共存，服务器可以同时支持 HTTP/1.1 和 HTTP/2。如果客户端不支持 HTTP/2，服务器可以回退到 HTTP/1.1。
    

HTTP3.0(2022.6)

基于UDP的QUIC协议。（待了解）

#### 4) HTTPS

HTTPS = HTTP+SSL/TLS，也就是用SSL/TLS对数据进行加密和解密，Http进行传输。 HTTPS 的 URL 则是由 https:// 起始与默认使用端口**443。**

![](https://img-blog.csdnimg.cn/f4bef0da85ca4ac1a927b13ba5b31dde.png)

首先先解释一些概念：

##### **a) 对称加密和非对称加密**

对称密码体制使用相同的密钥( 秘密密钥) 对消息进行加密/解密，系统的保密性主要由密钥的安全性决定，而与算法是否保密无关；非对称密码体制使用公钥加密消息，使用私钥来解密。使用非对称密码体制可增强通信的安全性。

*   非对称加密算法：RSA，DSA/DSS
*   对称加密算法：AES，RC4，3DES

对称加密的好处是加解密的过程中速度比较快，适合于数据量比较大的加解密。

所以https协议实际是用非对称加密协商了一个对称的秘钥，实际的报文内容都是基于对称密钥的。这样在保证安全的同时，提升了效率。

##### **b) 数字证书**

企业向有资质的CA机构付费申请SSL证书，SSL证书里面包含了网站的域名，证书有效期，证书的颁发机构以及用于加密传输密码的公钥等信。证书的格式是由X.509标准定义。

当然一些受信任的环境中，也可以自签名证书。

###### **数字证书构成**

*   公钥和个人等信息，经过Hash摘要算法加密，形成消息摘要；将消息摘要拿到拥有公信力的认证中心（CA），用它的私钥对消息摘要加密，形成**数字签名**。
    
*   公钥和个人信息、数字签名共同构成**数字证书**
    

![](https://img-blog.csdnimg.cn/5b69fdfe2c3d4b41b61716a3a1a984ca.png)

##### **c) SSL流程**

SSL/TSL（TSL是SSL3.0的后续版本）的流程是：

![](https://img-blog.csdnimg.cn/c81d9c84c4a04318acc99b901265164f.png)

1.客户端发起Https请求，连接到服务器的443端口。
    
2.服务器必须要有一套**数字证书**（证书内容有公钥、证书颁发CA机构、失效日期等）。
    
3.服务器将自己的数字证书发送给客户端（公钥在证书里面，私钥由服务器持有）。
    
4.客户端收到数字证书之后，会验证证书的合法性。如果**证书验证**通过，就会生成一个随机的**对称密钥**，用证书的公钥加密。
    
5.客户端将公钥加密后的密钥发送到服务器。
    
6.服务器接收到客户端发来的密文密钥之后，用自己之前保留的私钥对其进行非对称解密，解密之后就得到客户端的密钥，然后用客户端密钥对返回数据进行对称加密，酱紫传输的数据都是密文啦。
    
7.服务器将加密后的密文返回到客户端。
    
8.客户端收到后，用自己的密钥对其进行**对称解密**，得到服务器返回的数据。
    

### 4，TCP和UDP协议

TCP和UDP都工作在传输层。TCP 提供一种**面向连接的、可靠的字节流全双工**服务。

#### 1) TCP三次握手

![](https://img-blog.csdnimg.cn/0f24e36cee2748b69b5b70aab63b7a6b.png)

假设建立TCP连接仅需要两次握手，那么如果第二次握手时，服务端返回给客户端的确认报文丢失了，客户端这边认为服务端没有和他建立连接，而服务端却以为已经和客户端建立了连接，并且可能向服务端已经开始向客户端发送数据，但客户端并不会接收这些数据，浪费了资源。

#### 2) TCP四次挥手

![](https://img-blog.csdnimg.cn/373a459834dc45bcaedb4b2909c3fe65.png)

之所以需要最后超时机制（一般是2MSL）：

a) 保证最后一个ACK能收到。最后一次挥手Fin可能丢失，那ACK就收不到了，服务器端会重发Fin，客户端收到后就会重发ACK,并重置超时时间。

b) 防止已失效的报文段出现在下个连接中。

#### 3）TCP粘包和拆包

TCP是面向字节流的，所以在业务上认为，一**个完整的包可能会被TCP拆分成多个包进行发送**，**也有可能把多个小的包封装成一个大的数据包发送**，这就是所谓的TCP粘包和拆包问题。

![](https://img-blog.csdnimg.cn/80464b62edf1427c918a2fc4ae8217d5.png)

![](https://img-blog.csdnimg.cn/8f68df1423b245daa3e998747189a15f.png)

**解决方案：**

*   发送端将每个数据包封装为固定长度
    
*   在数据尾部增加特殊字符进行分割
    
*   将数据分为两部分，一部分是头部，一部分是内容体；其中头部结构大小固定，且有一个字段声明内容体的大小。
    
*   应用层协议需要自己设计消息的边界（消息帧），并通过自定义协议进行粘包和拆包的处理。

#### 4）TCP可靠性的保证

TCP之所以可靠，体现在连接和断开的可靠性（三次握手，四次挥手）、有状态（哪些数据发送了，哪些没发）、可控制（超时重传、流量控制、拥塞控制等）。

*   首先，TCP的连接是基于**三次握手**，而断开则是基于**四次挥手**。确保连接和断开的可靠性。
    
*   其次，TCP的可靠性，还体现在**有状态**;TCP会记录哪些数据发送了，哪些数据被接收了，哪些没有被接受，并且保证数据包按序到达，保证数据传输不出差错。
    
*   再次，TCP的可靠性，还体现在**可控制**。它有数据包校验、ACK应答、超时重传(发送方)、失序数据重传（接收方）、丢弃重复数据、流量控制（滑动窗口）和拥塞控制等机制。
    

有状态是通过序列号来解决，避免乱序问题；局部的丢包问题主要是通过超时重传解决；整体的因为接收发送速度不一致导致的丢包问题通过流量控制和拥塞控制解决。

*   序列号：TCP会对每一个发送的**字节进行编号**，接收方接到数据后，会对发送方发送确认应答(ACK报文)，并且这个ACK报文中带有相应的确认编号，告诉发送方，下一次发送的数据从编号多少开始发。如果发送方发送相同的数据，接收端也可以通过序列号判断出，直接将数据丢弃。
*   超时重传：在上面说了序列号的作用，但如果发送方在发送数据后一段时间内（可以设置重传计时器规定这段时间）没有收到确认序号ACK，那么发送方就会重新发送数据。会常识多次重传，等待时间倍数增长。
*   流量控制：如果发送端发送的数据太快，接收端来不及接收就会出现丢包问题。为了解决这个问题，TCP协议利用了滑动窗口进行了流量控制。具体是在TCP报文头里增加一个接收方窗口剩余大小，发送方收到后及时调整。
*   拥塞控制：如果网络出现拥塞，则会产生丢包等问题，这时发送方会将丢失的数据包继续重传，网络拥塞会更加严重，所以在网络出现拥塞时应注意控制发送方的发送数据，降低整个网络的拥塞程度。发送方也会有一个根据网络的拥塞情况动态确定的拥塞窗口，一般来说发送方真实的发送窗口为滑动窗口和拥塞窗口中的最小值。

#### 5) TCP和UDP区别

UDP是无连接的，面向报文的协议。UDP只是对数据包进行简单的封包，他的特点是占用cpu等资源少；速度快，但是可能丢数据。

常用于DNS, 视频，直播，还有隧道网络（比如VPN）。

![](https://img-blog.csdnimg.cn/9159004966fd4cefb50be2993467454b.png)

### 5，IP协议

#### 1）IP地址和MAC地址

IP地址是网络层的地址，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异；

MAC地址又称物理地址，由网络设备制造商生产时写在硬件内部，不可更改，并且每个以太网设备的MAC地址都是唯一的。

TCP报文在网络层会被封装成IP数据报，在数据链路层被封装成MAC帧，然后在通信链路中传输。

#### 2）ARP协议

ARP协议属于**网络层**的协议，主要作用是实现从IP地址转换为MAC地址。在每个**主机或者路由器**中都建有一个ARP缓存表，表中有IP地址及IP地址对应的MAC地址。

ARP的工作流程：

1.  在**局域网**内，主机A要向主机B发送IP数据报时，首先会在**主机A的ARP缓存表**中查找是否有IP地址及其对应的MAC地址，如果有，则将MAC地址写入到MAC帧的首部，并通过局域网将该MAC帧发送到MAC地址所在的主机B。
2.  如果主机A的ARP缓存表中没有主机B的IP地址及所对应的MAC地址，主机A会在**局域网内广播**发送一个ARP请求分组。局域网内的所有主机都会收到这个ARP请求分组。
3.  主机B在看到主机A发送的ARP请求分组中有自己的IP地址，会像主机A以**单播**的方式发送一个带有自己MAC地址的响应分组。
4.  主机A收到主机B的ARP响应分组后，会在ARP缓存表中写入主机B的IP地址及其IP地址对应的MAC地址。
5.  如果主机A和主机B**不在同一个局域网**内，即使知道主机B的MAC地址也是不能直接通信的，必须通过**路由器转发**到主机B的局域网才可以通过主机B的MAC地址找到主机B。并且主机A和主机B已经可以通信的情况下，主机A的ARP缓存表中寸的并不是主机B的IP地址及主机B的MAC地址，而是**主机B的IP地址及该通信链路上的下一跳路由器的MAC地址**。这就是上图中的源IP地址和目的IP地址一直不变，而MAC地址却随着链路的不同而改变。
6.  如果主机A和主机B不在同一个局域网，参考上图中的主机H1和主机H2，这时主机H1需要先广播找到路由器R1的MAC地址，再由R1广播找到路由器R2的MAC地址，最后R2广播找到主机H2的MAC地址，建立起通信链路。

#### 3）IPV4和IPV6

IPv4是32位IP地址，而IPv6是128位IP地址。IPv4是数字地址，用点分隔。IPv6是一个字母数字地址，用冒号分隔。

IPv4和IPv6无法相互通信，需要怎么才能使用IPV6呢？

*   操作系统必须与IPv6兼容
*   路由器支持IPv6
*   ISP支持IPv6
*   网站同时支持IPV4和IPV6

#### 4）ping

ping是ICMP(网际控制报文协议)中的一个重要应用，**ICMP是网络层的协议**。ping的作用是测试两个主机的连通性。

ping的工作过程：

1.  向目的主机发送多个ICMP回送请求报文
2.  根据目的主机返回的回送报文的时间和成功响应的次数估算出数据包往返时间及丢包率。

#### **路由器和交换机的区别？　**

![](https://img-blog.csdnimg.cn/img_convert/6bfc4b0ceb5a0e69c607818d2b46752e.png)

### 6，大小端问题

#### 1）定义

大端模式（Big-Endian）：指的是数据的低位保存在内存的高地址中，而数据的高位保存在内存的低地址中.

小端模式（Little-Endian）：指的是数据的低位保存在内存的低地址中，而数据的高位保存在内存的高地址中。

#### 2）应用场景

*   计算机操作系统里都是小端，网络字节序都是大端
*   跨语言里需要注意大小端问题，如java都是大端，C/C++中也是小端存储，Go可以指定大小端

#### 3）如何判断大小端

可以使用Union数据结构来判断

    union myunion test;	test.a = 0x12345678;			if (test.b == 0x78)		printf("小端模式")；			else if (test.b == 0x12)	 printf("大端模式")；	

### 7，WebSocket

websocket是一种**应用层协议**，被设计用来提供**低延迟，全双工，长期链接**。websocket主要被设计解决实时通信问题。因为websocket是通过单个tcp进行双向通信，链接只需要一次建立，所以它相比http延迟更低，资源利用更高。

websocket定义了一套标准，目前很多语言模块和较新的浏览器都支持ws。

![](https://img-blog.csdnimg.cn/35e4988e1869463e827f404c734aaee1.png)

websocket链接的建立还是通过http的，但是在协议头里加上upgrade:websocket，这样服务端就会把这个连接升级为一个专有ws连接（基于一个专有tcp连接），后续就可以双向实时通信。如果不发送数据的时候，为了保持连接不断开，要定时发送心跳包（空帧）。

ws协议的url是ws://，默认端口80； 如果再加上ssl层（需要自己支持，ws标准中不包含），则是wss://，默认端口443。

#### 1）WS和Socket的区别

具体来说，Socket是一套标准API，它完成了对TCP/IP的高度封装，屏蔽网络细节，以方便开发者更好地进行网络编程。

这两个概念毫无关系。

三，总结
----

看完本文，我们了解了：

1.  浏览器输入url地址后的事情
2.  了解了网络协议栈的构成
3.  了解了http, https, tcp/ip, udp, dns, arp, icmp协议
4.  了解了websocket是一种规范，也是一种应用层协议，及其应用场景
5.  了解了大小端问题的出现场景
